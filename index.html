<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f2354fb014d7c92d5c749059892ee453aae1ac6315012d4e9c2a0db4c6393ce4029347e8dfdc032e6f205f8ed221b2e8955827a35cad0416100e26b07342d92b7f226aace71aeba347944ba679889d185bef68a2be635025a52d91f102ec257f76e1d259b8fe0f7656c3de67f5bda93e235ac65ce4fb73d0799bd91e7caa333412ef506de01b9348d110dd19ac7121d1dd8d6e4706bdf7b27540f38d6eb524137ed58a95c28677cb29b3d559d56984b18345af2b1648c411b546c6283c132261a56f11014f163b41565150325a71155f6d34b86fa3e7c1c7b9f1363a134752403c03ce4e1c7f15717cb363ab644482275e0885c759317f1f55795b01257397d87ffb498f3f060bc220ed0bd9b0048e9497004bf97a007f9d0fc5d0cce8ff1892860a13d2059dd231399a7be77d4a44bc548186957d3804a43c123ae222d0bba8bfe65329324d0e50688135c91027f3268a4d78bf0b65d05e565c9e9454b9da1e80b41247c8bf9e9d3ec13f17a0bf80697ec37c071aebce46b3c573ab0d954b4bb50d0405c589c66b4cedf344254b36de30c179f9fcb51f4ea165902c3066daf1d623f5738fc84c4ca0b6da76e25684d83548be2f318a891361e7728ab9a7b76188be597c5a89917ff12eb47a4504f9967986e4952e404b9ed25217d9761aee46d27ddf90bf789788cc8d00b786528a75c918491787e9b347a3c500dd272db666e26838f2e2675067f65f97e6b1a8d64e4343d63cd2df980d9658559e529c013b937806be7186c8ae3ba7d963afb5e72e23b36deda068249f2cee640fb648de5a98e4d202187b62796173ce4f5388940775f3a4b2fdf03a989a60fc767556f7d97483e7f4dd84025864204eb76d8e79aacaa54ebdb9bc0de3d3d2578a1353cbcedd45a8ab51081f11f0b71bb197f18be2445cf904aca3f925ed23a1a6fb52213b31862e43dced1fac13c53de9526e41a753b6fe99b85969221c7e2c3340f3686ace1ace63679f0ddc8d47657d46e99215d39abc7c568fcf31eba28f1491aea8f7f1d1022d6051b39651c2ef77c442d0f51acecbaeef03fdc8e37891a77b3e4982f362bcab52e36d1a3d65369b9a0b6761c796e1194b722b292d23a51ffd475d80ec5b9f02fd830a0d48151393fa58d6a21382b80340ad935d0196d6fb3575f77a3b8e71d7db1b90836852b698776ff468e91e7898014f8c6c84a890a3b000851e9611ea5f3ee9e0ac2cd12671d43f0d24c5d6d603ad485a8012e7a882caa53a1cfd98836a67014f19d428cb72116ed40cc45bc0a1796bc8b77165a881d47a3a0d0fe9e113c3c0792daac9618cede12593e224abda30cb29ca8061702c7a3944e45af4c11b2a20c13c3ab46361011f71b0a0ac8b6d611cf38e5eef45e615e989f96ae9448564e859f799140a9f579c96617a3cd1dfb5ad7ef16d33964c3225afae7b181dc009d5ea8a116982e691f9fd7e9dd114cbf20220120a80583c40cdbd8730bf17848911c18bfc1d27adb1e69814d3c9c85cad06a5a72745d4c0eb4ab8477e814f3f107799efc9eff817786d19ac577daf7dd771e575d17598e0704ed2ca6ae9cabbf7ac60d32645cff3ae26d8d7ddfa38496a532a07ba6027e60f2a873c92c7bd7ed145a46cdd2d74f9d66623d6f382715923ea18ca299536c3a76b82fea85544b2d94a7c3099641bb7fe1c38c4f1b2c219f257bbdbbb5836b9f6bfb4962b340c8296fede498683a05182b47454c7dc03b5335affee553575ebc28abb3f51bf99e1cc4434b0235d36d390557aa4d6060413889e01b04c49ca56b2f88e871dd4d218a5327df5a9953b01a46fd4644180f18722d7ecb7e0c2cf7f5256f585d0c32278b8604a2238c1b50cdf66b0b3bd28bc771536ffda5a246cffcddade36cce278a1d6c0e8e6d0166ca4258f904134e856ed5f8dfd6ccb1bfa7cee2dba4aaf8541fda957d7113698f8d84a4c4d8ac3bc286d84b2fc9dbfc7dfd9fdb9d1760e6f907afb7a5156b73318dbe727a9465418514ca7a1b72ba3669787fbfb5c8390055a6074563409c9694a39be819d64f0ced54a849325a59cdc82c409abc18ef66fa8ae0a7fed56d7f4c526bdcff12b22d5c80de155952ba32740ddb3a8e254f0ed3226ecf0ee5ef1c429cd8079488a70baeeaf19ec607102cdbe3263ad00abf7b5b49874fe5489042fd26132a3f2b24415db14e554281fab0491b64187b31b171a6a34c200c8d387cbe250ae42270b2a5b0c9528842d41992fd87d203b627b196f4c252aef58a4440b9ffa7ebdd38a730fcc21d45da7abda11305d9b2b0aea4b6e3526f0b929cb3b8a1476efc965b21857fd872bf0afcea9da02c78d27ace12f27b5261703f92de84fc0bc4b8e9fa9097deed7abd621a241937cd50c34653653657b2d8c1e7182ca7ea7a6b8586cd9eb35d5e42dfa097b01fbcbbb1f662ba9d528f49db39829348435749cefc5e5890eafd2627bf843c7cdf8a7eb3b861eaac83456824b97163c4ee13d096e00d357209aa2dfd8c6e4800ce0655912f1086a36209fbb3ff8d99d186012300ecc0c9ba26b76da303696611b3e7db3f373177450adbcec6a5cd17c285fcdc75c3abcc1fcd8990103d897b8b53e315eecd2ed2a930ddf9aa9aa6c8a492504bb1f8ef245a16ae926dbe97aea8ad506abddd496c86eb0aa92efdd99840334d423d3019eded774fcfb1bc57a34800734ab8579e41823489c6f61c6a0744c7b626b927d45ca923146b49e0de3e871d9cc84466a4f8e406422932424df8865cd6a0fc47366b998841874c9232c95a8055775e8c069ab20f66d90304facb4774a0ac8e74a5841ff62c1974cc5e44f3b0544dcfbdaf75aa2d142ecfa3d4f3334b81ebc7c3d4e84535997714b3a2b53b487c18547e00c56ff0e52a63d301316c3c6774d82121f402bf353db01e08f2e5f7da7753a88d0af172ae03ce186a9677aff1ab36cc91d01c5dc134ac3d4d17cbcecf67bce38e846e18915b10102e023cb4825958205508119aca78480d1ab34917216132bd8307f0246c666f61fd9b8a19eb50f55af80abe637f9cf2e8ba7d3de32e88d2f2d0a06b526bb939a038c06780bbf492a8b2e981bb11f6ecbb367e865caa8b63b09ba49524c44fac0c84ad95958940fcea16a5f0675dff80be0d5a8f2c614d2fb9c5a17ab9e3ede005d4405a76b4fbcd9d3db1c5e82d1c1951be2ba8c9b397572e3cca5434be9e49ae9609a82819cbdf63eb1f8624b0b642bdc726cce2523eb27ec5de10a68c7087b908cf67437e352fa69e1de83c8d6742edfa0ec5da5593294d0eae3d24a0e9c429b8da22c1d1a2d8bf9d70607bd51e315a1da8aca48c31772815cb8876e74209445fee67558d6bdafa029e2996010603924e1fa30382256495c7d8667429afb5024bc377b2df5aef7ac28ff778a5c3c60d16e7d568f33b297788bcce7a743af9204eeb9d8f2b3e1765d343dad671743e403379e4745ee778f7a51004ba62c1da78135317fc38f2f7b21a53d4c18ccac95ee41568d81d1a8a409618df17fab9dbddb3df3079140b66939f5897cbd3d6a58e36279641d331b5a0cc7322746010ff29b6c5c889c1bc4966ce4a7123957fa22a18af772d0590450b103d121619da46e442414131f3156ee52672c4c3fd74563b4305abff64258b6a4f1378ec9dba9c5201d711013f4ce0b424d03c5200a4abf78f4850363bcb6c0bc556b68dabdd1a8e35a4bd1f96c0c2c3b06f509875cb627731bc08657c5177dbe8616c2f249bb52fb77e5bf368a0826a23e0734cc4ea5f954941630174ba4907067137acbf2ad266a835bd413dcdf57f17bf75570dd8d46041fcffa642a257e415ed857eeacb5118906581d2099a4c4c3852db9a2391ac0d159f3602718d0c15c939ce1342c17a8177717d73ffaf7ea6e31872e0ef8a8a5e2a72340c7238685715e2a4b19617c9e683c59588bfea9e0943b1a4905d017d9a7f8bfd24c0721dee2891842a6c5f0fa34d5e0790cf7950301fa04a0560c913cc791f7f37ca9f7ef02bb71733e02295099fa0b2d0644fe3ef72f4f65f0cc08c9960add68b07111ba6d5adc181423c4e8a6f5212d19a463c46ef617d3c460857411bdb949296db7fd53ca52b9f972a71a8e0917fcef1b6ab7c2158818f7d306d85f838c35bd1d17e5b663e16c409d2dd82b7736733146f6b6f7e56001b4dca9979e567bc05adaba813ab79a69260bf1e5c82b27e24481a1de52208a44df7cdcec01479ed4b18a0102b1835939f082e0c48fda47fd374cb9f640c7564736332e2e771f6d9f336ba1f909ec2bcb3dba8642aed17ded3ca9a1f2826a81e5d6721b1dcf44128fefa3541e1473f765209cb08f0908dd8d9cfd8b768545507e010a45224b12e04dae266f0d1c72c8cd84fa92485c6660c5bcd76b4f2143eba0f5cbdd63e0374875ad3a4012c93c144aedb78ebcd7e9f350e14a6278e020724a4dc7244792ab9c1beae335d8754fb0c8a937b094763712c1d0184852c7a855b592080c206d71dbb492ec0224a10d42f22bca91e2968239a09796f688e056a9639260a9bb022fa82c38e84e98b9341f94b82a61f903adb1954785c3484c1594ddbdfeb450b3a2ab2e702d1bfb96630d230c395d34f684ee35b86d5802a49994a539561391df1cb17c58d7dfeccdb4a8e57538ff06baf24a3dd9e3e22d8439686cc3b9cc72beea3710fa389ce3f3f984e62b08005d7a176754fb97f610e7b8492a20845803cf63349e28ecf4fea71ff38dfc1b14cd71313a3d5d25c22aaa5c486ce8e481bb9b01780bd3cc5543e8ab6d55fe9e10d0d7d22e5316e19977ef83fbd8b152849fb2453632224d89d041e6d9d81bcfbf242c22bb5dc35b08537bf3f196c37e0a5cab73b3002a6aab219f437a61cd11f2ff7f4a9dd24c98657a2cdcdfb3f6f7bdeec6ef24bb329fa76d1a20b168c89e895cb269ceecb4a305bd5e015593a951cc0212347f85b224389d8bfa3c6e4df376e8c6000eabdf9031896d10687ced7c463578f726de79a57dd6e06001a61a5a1a0c189a6c8cd2f0ef3b03eb09fd13413eb79d7b47757a6700e7872afaae023d1de470d1b0a8c0a6a7edcfefd941ce36a207f5d3b67bac6143feaed8733a17145cca3a6d12f7b157a13f38f7d5ad5f1bac44211f7d7aea5f9d30fc9f3f5b5bc03774804e4c9d68ced1c308e6ff8e88eae06428843b442a9b9a0b60fcb34132f446ae2f90700e5b090d295b9971312a9c5f525559d6b0e822feb80b9bb0604fce2a7d8f272a36d00949fa7c05eb2cffdcbcb4dc2776fa159ea76caaabefc1b37c6e2b2e537304879306f07943a0342b0e2ddc2ee4e12865055618393c4df0d62c40ef5e59127ac2c2918cd532d1cfaf1641c5ab2541978d731636ea47c82ee882cffec0cc2d2e6fd0877bdd489aabeddc507fc35d5fb822a8ffcae739e3049075ea5962c513871bb7bd1fbdd75298a37f6ccba66f1de52a16d76a58c168585b63a3bdd368b9836fe990e5db6b60945bf76acad7d6c504d921a6d75e4d5c715fab246b825cb6431dc473b29821e1a3fd4c2b03316dac14d98bb036d99ee203c3f5b963a45c0e9e38d3017d2accb32d89f62bf2b999d20bef66801731b4506e9e00217319f03d3a23c46e68e1fc0f6ff7449acaeb54746f0529c2042e0847178251b5afde73a52d21a5c99d7cdff196e6a4aed58632903c3a32292cd351b0ad31f5437c483a083a5f30e736d4c50433dbfc0d852d8fc17ea206e9eb2e0df207fb41d69b0ca496767713b15a52b1ff66d6d089452bb0f9133517fb1338a424c22a0c8ddb77cfe5c42db0272fc006ac7c5853edd5c67357618a20eb5b0e9e4c09042f7bc49732b6dc9f9412d7083a76b7a2c8d8f35a9e0ca611c171d7f1a75702afdfdcccf86d73ae059f95f1781e21f449f53004b88a601dc924eeaa829bea072fc6b4aa643900f2ddc7635fb32b1556851f2a4dd2132952183dbaaa81c88590d25c576ce207677a64920d028709b63b44cd621a0e0971344754cf996e6352438280e1e489c987fbf5184dcf5ec6c6a9047a93d1d01e04b86ea510bf8c6da9cf22519dd4a1c4c341280db28b97321bcc70569548681c6037a499f619c4f8c453e3bf86569c664cc29c428ecd8c7d9d1b888b995c3a12456ad1b91ce609de0af087f01c66ed16c857b2facfa3681109a97b9f3a5caa67888780373a34752a1bf2ca43c8da412ecf147fed177c3c5c82ca8d46f6ad2a40e9c48e406a56ae34f371e46cfa532b9db34c7b9bf091262f15ff64a6b5175c8fe59dc82a6d09ad8e6246fa5f38a5a5ff7fda788d819b9f8bfa9c9e3561b44765e721fc6e9544ebb39722826d829cd189ace166f17a777a53a4c7ba91c5d80338e3ba2b4b2095c5a9789d92bdd4986106dcee97e821b04f23d1c4556c6b0488ab6b27348d1ae885bf34e9bc4815da6d60226244ddd85a0247e52230b1638e9aef61de27bc9a5f97f9b2141f233f8dd1ce62f0b888c13c9f188812df968ec1e1d82a76111364ff7f08bb0e2f1b81ac5229a3b9f9417496ecea83f8308edca78bbb28067a31948b0afdb3afb0733d0b8a96d4f3a78fd76169bcb649eb67cad92737ab53d71a7f3d860e02150afe2d2971d0f87b4aa1a4b7f91af0576bf07543dc9c3068976234273fa9a709e92c61eb2308e94048ac854fcbc48976b5b99323d34bf389245d4865681e5c791504d87c3c56bd11fa82c5ee382175ecb5159348831d7fc58f53cb360a9d611e4bd0536897aacfe9e255b1b081354c28b011f09e22e700bcc71f60b44e7c6c5616756ac3195a25b6fb286ad6d09015e0c8dcf28d7b63b42dedcb6d5e827705573ee5584322968b36d3ec09da9c02f51a2ac222d9e361f3b513c4dbb322dd95edaeafebe19bc90238aa4cd1ac62c488e1ff271bcc4b6b8f1e0acd94b87529403955ac6aa4ff7c59daf0df5dcc1b2583660b81283ab6f227236607cb1179dfa98c863fe8fcf3c82b2eee8e2d70d11e3fc84815e1465df10fb969b0f6df8e4c79c5c64b2209dcb4ef9096072c24c1b8f6c320cb2bf305ce4dcc2bf600bbdb3ebdd68746666f9f720fbf78747dee6f9b8bf5bb4c9f151719580a0204cb33544257d935b643da34a3a9006ccdf73b6c5c9db0c00eeea26f2c321f5092a361e2abd2378eb63bc24b48a9a1693dc28f2119adeee172e666d478c741c50a28bc965ec3127c235fc27c609e58427c7bd971bcf005166944c0cc075b9cabed600f1080821dd5b5e4900dcd12ffb74e6fff389be2b47cf61aef49d3354dfa58e08aa34fd29aff0196c47c55ff96f59f8401c87594c10066aa6e209a5ab28585a9544d4d04e639f0b7a2f8079e30bfdf99e5cb80c93deb7c9e00d4cc76ccccd1a2d071ad637f47ed0c7eaebc16334dac4df70eed7117b9b47ab874730052c88e7419f02ebcecee676c01b1ea288ff8fd376a646d2a5d8fba3e2a8a4d241f60abb50569644d348beca94fbc41ea85d7929716a3e9feccf4fa18949f4f57e24fb6b7e70067a3e96d0fc54235c4f1c5ca3b699a27a104275c72cbe90c036629e2a9313485b03aa255b7ce15268ea38065d451b6c0e6eba296d3f958d80ec502cf545ea8d2153162643a46fc3bf7e2879814398f5eaa40dfff245fefdbeb22edce35de8f37a7bba460312e36757f643c6b18e87963227c9146cf3a313ca8892c2d9733c1997d17bcf43837d3b1d5f156b290f8439d726c4401a2d79cffc09deca33e2026fefaf64f232ec25d4e553cfbf53112ee85ab9affb1abef798600e8b21ff4abde4b85766a2d3c5bba7098ee5ec6773fd5a8e5e87d6bbbb46643acd183fe3d2047bcf5dad1d5bf0d83b39ee83614e180c62fea7e3550b1d7af248d3f6a66cc09c00f89647266c5b7cc0de470fa9f4ef63c79e3e023ad7300e4035cb4d3705e5b5bcaed3ea6075e2286968b87082534c8c20f1ad1a4c55f24764dbad68852f2e816a2f92c0f6d10f6c4549e33c96f01e405d385521d7c69e1c032cd19262ea699f7673bd581f7e2b821b8854b80807c512886de826611c9f777ad4ec8de3b9de61cdec01e2545ffdc683bdf81a7e0a78a29fce7c30c33e1b92dc0361e1077b7ab11ee22338e79c10a6ad214a6cf20dfccbb4c9b227ffa677b23f88161721ac8cd63336f757fdf604a4234bfbe9867fd6620439086dd97ef4bb08b5b7363679b9d7d3d03b34fd7c94e3d625ecebfcd914c679caed02c89e4d93ece794e5b8580fd4c559fd077e6a0c7ad7219f96532f15030196d21a6828cee97ff1fb50f5c2fe30c327f571cd3e42d48f9465e12a1d06104d741af6a370f518dce691860948f3100b3412dadeb802e6a2b83a2aa911a0dcdb98cd6b54bf06a08a0f3171c919b249519003db5ef62244443d886dd487ed019c6ddb3ba70a31bc983304a76ac58de30874e074ec6822bc48a180b8b59608ad970c9d5bb2f01231b44e6fb08c5929d6101d65a9d520ceb6c70a1a40160cf82caae1f92cfea7d00be0f09a71b65750326a3a00edd2f96fdcdd1b0400999ef3c4c4e9e5328602d12f544c56a79f1ded61925533148e1af77521e86f90337d9294a65a3d539b27656e4d2483bf1c3ce4044b383d1585289e9211f9acdc415144ef267d2400006836ea1509f33e61d6ee57191dec8aaaef11089933202652798a7f576dc90a1b45e3cab5fd637a4afc27f49f9648662a657ee551c466d19fe26bc28d7b86d595033875a4efc2959167102809f7621c4bc819bd0bcac194afa15723f4132d8ac724691cb36471ef3ef4afe2ff49d89376070baa60598d2300943f7a7ccd7e8fa55c67b94572834120129ef6c4c6aadbae779acb15ea214d8cdd18d7f5412e53dcc28e0bc185d7088059dfe31fc1cf1122a62ced0d20d776c0a89dea196b2af2713570053b47b70f5fdf0d485fa1b9969649e1324106e16766b66f344241398fa12a1c43bdaa3b402ce39bdeb0daf9ce0b95fda85124c6a3fab4a7d5d6ea050a44eed2ec35525799414e22b502de2ce37b363480906ae269038a4cd55651bc4401a2c162590cd2dab7fefd197bf7383eeeed33db966b0415a55a3df622c3fa25881769e9fe88338e6c46f9388b81d87adf681367f7513436f87620892fc904f5d9af37477b066b0fe5a67cb212bd1713471b081c0fa504d91506b2912dda3d776b55110ecf71dc3bc6707e830fe2031c88240aa0b373a59eec86c9314270f71ea8430bb79904dd05122b9b54a36244a532348942a0420dc339a8e8695f2d0e3834fe6569d18d73d4280f126a408cbc07a05a2f4fe70c2e88240115a6da4cbd2d446ee1257190e71d7d9cb251ab5d7bdd3f862c0abfb50e56af3e627e51e90377454a998909837a46b2417cdfff7ab20cfc714bee9d13ca69ce07a7d4cdfd5b21ace94cb4dd10d9cecce37c2cf787c9a9de48eb473f2b825c13bca531c9e1284772f3c41ab26d47be77eebbe08d31e89230cc99c784b1cce2471e5a93a68d0eb761504238b81489a787f3d7b7481e6f9f6eaaa7bde9c90fab274cb0bbef9b66e1c5134ece9c28644e5ab18b6818a539ea9d5c593fb2e5fb0f494c9c324051140e9f1021a5fcbb5bd04921c62b51065c894fd8ad83a591140964f294fb84d214c691c19e05e9ac442e01a814a1ab095a6a6c8b13d49d5465f6cb756b06f73c7a90d662841448d78e132dd3c37c6e097032638dfa118b493203b9dd7314db972f9b7811d6b50c3e529e236f82456464719bede52f75adb6f5a732508a56bed7bf03ee55bb82f1ab254f4e0e3a30677997b1f73e323b04b5f5ca172e92fc6577a396f577092ac732faf572e717c8d12b79e7cf6649ed99f892cb11aaf6bb56f8815aa63e8e306094fc60c288665aa20e081bc9888397aed68821c1fee955bc6bf5258201ce0d9a4c4f9b19c0b98f3987db0e4b12c4f2587b300bd1a69ddf563eff9559af119b4b66bd67f2abde54de246dd6ff3729c350303f4770a9778d002cb2118f1a92a776f4df616c2d9c8bd89358ab972fdb9975201e9e2cfc4de5afc2394f6b4f1db153ed65cf9634596fb1e90f5185f5a5151eb89a50c22cb245df6725e7d0957e7169b55d9391eddc3160faec7420145acb148e8b3f681e700c451d1603ffd45533c787569dc2e4534a98c1823a335dd6ae153d257b35d4df4ff2d6690fe47ea352bf9553d1e02d655cd1af74b067791654a1062528dc7a2b71b6439b4dbeefd1b3b2636aa63256172b2e711564263ef97876834dc4cdd202f84db216e738ea4dc601c0b44bc35b673d01253e70f3a7c4f668ca34aa1062dd185e34a9e3fb93c93218239850846e6e687347b41","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"00d2c8816c881225afe5d29e9dd0e59b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
