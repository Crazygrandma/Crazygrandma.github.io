<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"65dadd49230f486a9a2cdf3bf10e6c8e3423c25b8932aacbe7ce0db7fa5be3f95847df5983039694bb609f797403c36d97ad2a5f009ee6173fb536939d564b5643b1262618d56984cc85a55067722a05d8ffc383e482d00c023dde3b21d52156b1699eb5ee576ac5becc62fa9d61afaf0793c08a2cde00cb4372685138690b6dcb6f0813cf28abee7564ce39c717fd8536141d1b484f003e3b2689ba5e4358f80cee72887f6d487fd8ee8924c6baaa2110521e7ce8f2b905c6569610516192412b9c1eec19b1dcc71aec188c53b17c15ced07a9400472187d540c8eda6d0015aaffa9dd8f4bd855372e6d73b71d8eed90ee30780300d887b50a4dff221bd959976fb3bfd7a2ff2aaf988c373123365e5c73ee120e598e328401ce1f3998b5aa4eb8c4b67708cdd539150e95c10b0012ce5a3ffec4b980b4ca4cbe39a01568713e4aecba1ace1433ed73c8cc623ded0716ee8ff7f69054506228474f80a3e9de47c04a62cc08b9b23a2b022cf3e8f4d2d3f71908a17c64a93182561ee273770523a0d3b29578aa92bc80510d2a6e59f49265372af568c3ed8df2657012946f67701b26420e30dc8306e7705e05d059c9133bec2924ea1fab8c955499ffcd9553c8321b9e59b9775e4e734b0f94e0a993eff9317a14da30c5e8af5556a8a39333aec96020368c730ada1a7c22a4b9c3d078ed87b26f19f067362474c5c6ed8aa41af80a03516aa0bc82c11012e8b6926dce1276e7402c5d6af6c443069a2e807371e2781ac82b377d92b71c9ecf3cbad3d67274f31e54f8ae38f219258ba0ac84b2ca57645b7e6c9ba070c8248d4f4257016c0c77ef2a6586408a77a836c911824b43f5e948e609046dc36fdaee87d3f7ddefb1cd5adb7818e240449241b78a2e56468227d67659110ad5f08b712c9954e760592326dbbedf64764daf8401b8dc209b4e92b54c6ef0495f1d560e5dd7a64187145844ac81dc1c2b50525acbf5a7c55938de8d8a1b848a90c8ea19f86c7889c95764b44e5662571e9349d66bb7a43c3b77481b7b9c3a083c52bfcf9a4b7eac65f2832d7b41db0da113121691604a343a184a7eb76a3c289306319f4e81ba11a44bb087dc243e7793330e5a1d36d27cef47c9acaae0e7a9c75be2bc6551bd9f38e31691e22d2260ad0dc0db3dabec7b55793b0db7237a086b0ea2dd65c6ad2e55e08c86253d9f62e09cb0382e3741ce87140a2860b2955a3f786857300ce5ac89784daeee14e51b6a76520c49ad980c679ce33cf9e8e05fde461ab8cb27fdf8c4599ab7ea4cda7e11f7de6bead1bcf19783d76c692a9b3cb16dbca8080768aadd959d900822114c9171bf88ecd51fcdec0bd20d1de161c3fe48473935fb00c2349417736fa7c75e308e6e67d2456fe7b933e8de39a108ac65b64220b84bb44b265cccddf4044a0ad0320b4d1e824a0d0ff3a6cafe8f886b5232f7b6a1db2bac66d209d2d44dbd0023dd3b4fce8f1b91b525d449397ded4f9cfabdcb14ab205c1d65886a8b4bfec9d32e10285ca893ccff5f4cf028d70af9a0951abb59573ec53b944e63d7c72cc2de9736345b4faff9a87a05ee78adc823b0e0e58069eaab936bd9d80084d0df79a80c70e02034fa9600c19886fb406d18fff8db85418a6657b2a0ddac6671890913f717189ea76350728ef0eb166d211a2218ef47ae7bf55dae345d01979cbfbaefeea3472e46d948a618758e88f675e1429b2fd33a34cce309757682e9ce1242355e53c9f2412507f1cf1ef5aea034e11f84f5e7121e0de153fc3f896c51f9ec845a31f9a018fd80864004c6196ae01cd20ed0f4f429ff1ae08f525fbaeb3090c51eb339c0d4d3a3d4d3a66b850d09a130785a62e7a3c91bcedbd4d995da5ec0fb7b028a0b2e76e95b429bdd74add6fc72426b4f4e11bd2bd408e911d8108bbe4adffee016e6d853b2ad533ba1e4f9bb9f28c483549885c37c7dd34d04c12f5aef754ccd0b9dd3b4cced8470fefa040401eb8440c7e665eed4e6f7a36dd5f560426088b3c7192e7b59986b737ccd406b1fc24ed507fb34e4869edc1a9e31b994a4cbd595a6c9eebbca06172ffb7aa75d061106a0327e10f135598f17bfb601ca448884b7089a5f9516f53226ced6f1d73103c9263ddf9c0d681e16ff1a909c05ab53e97842de8bc38d70ec82e88162daa08901446f10cfea8c8a083f82324a08bdfbf79c4665e8e93638fbae6bc859430b3c3081a2226ae5812f4d59c42b328e44a42b9d3270820678712a4f126663d759f56af9676fcfd5e8893458193897cfd37d124d75ed27ea135505c10a044467abdbc3f89e7bafe33d1f8a18e2ed10f22407ef835b7a1ea297cbfdf73032c0751e8e067ac8f8ce447d52c2eaedfe8ee26e7888d93e2a06407af80a80f78ead05e96cb464d4d53810f2068f95809c20470e71afe8b4f073018ae05273fdc1dbc7b2082188b11fc47283f8d3209a41720318e692b05042275420c4530c0c87053c0d51ac76611a1855c72374df7b61aa926123e055859446d059c50c4494a15c5da8717b15ae5a1977a0548c1e13d4318332dd53e1b3e17ae62738ab443ccdf28cae5cdf07a963ea1e0ca9ba8c80a2a36deee51d5551e2a9886fb4a424dec6628440289a09868744eaf73dcbcc327a8f11565fdb1cfefd5ed9ab4400eea0f724d3fce1b4d4325d6346c0d68fd5d9534a1abda8265b4e96007fd24575ebe34a7790638a5b16f53a4dad12f2ed8434be0a0ac0fbfabe6a11e3a783908f1daee0b14ac5ab6604f27cbc166a39a8c8679aceffb48d7ce6ee651d3c847a06cb6589b8dcc51e0a0561d5cf89f5f5bdad4a4f3643f72d27fb7c527ddc7b7624ff6d184a2a827f45c82204981db16083c1ab5baae90098d9c71313556392dcbb32698c09b4d659f209517e70d3025b199a6602b79badac0c94c2c76c9ab179daebbc17de9795e231bd9540d634be22af3048fbea69436b2f2f785191f8624d4a0b0939238309c0cc77eb23d94a9f5f7f522dad08e039081ba39c1aa69223ca618d547b6af735cfea1cd2c2ad1a0c04e6c25ed1bdc13bbf145835662cbd7523d8cc7df78b9134abc2cdbeedd6f4a20c84fc5786a96c8a8174b3f4283080c3f4356bf59020be0d2d23f29afb16ac00ea04c74ae0fca89ac197dd9a7cf9537f34d8086ca24d21c42f6feb05f5b98d7557e1e78aceff82911de1a473e046305b377c62af3239034a3b0305969129bc142f55c7ebf25c2170b8e58e06d8de762f4ec124f1782ed803c7edffc529dc98c00519b55bb30dc32a18ef23fb68c5774cf70d75895bca0b623026f7679af606f2c60a3d45754d52b0ad9820ddbd5726562a77bd8f52c946c5375d1d4c96fc9907bfcf38cc5dca62ae5a412cc22209292d2a2ab2ae79079a5c5c61334c39c519cabc4a5d9e4990827ce0715b8cc38fae4229d71c582af5dc1ed106f5bdb5f50cf61fc05c7ddcde379e27036c53d28c55b4374a12e21306a04a162d3eb982058ada5c8c1a2ab550cb3ff9ae3addfef8e95194fb7494ba909f54dae636f877862e2021a79b242ac44969baef1bdf316392ebcfcb9250ab13b643edc92ce77bd1788790d1f84e9d1eeeafcf0eaae5ad47ef599b0ad9304dc318e83949f972407e406260f898bb3a6eceacaf119ac972b0e2afa541810baae3d2d4b8b138188fc1e8e63fa67b5b595428801cf2e2efe868073d5a1bebd2541373e7e899a8bbf81b3110a7152acfccbf1d390a638807a7b7a37b79ffbad4b7f3e830578a78588119bd6109924503665202329471d1c21f4450f760ffd053b0942a5278cfe652c767407703f960c79c3e21c7082bea99b56cc75c1e945c1364a7a7f6ef272e0eba1163a8aefb4308ef1e1b79e7021c6f370848100bf811dcf19d0c7722129d2e157a32ea8193eddc82dbae0c2414bdc4f92372a1edb8e51c741398e1f4e07d4b82090149fd77b571b52e8bdad2fbb231695a1bfaae0cc32c60f96cbb16359bb01abe7f2d665d66f2fa2e327bba2bf5d512db072d6d17b703387d806767742885cec8636f6cface877d641393becdf385a54c8c3192ddc448389f9fa8ebcff223516261e893e2d773c21f073ff7d6e6d0f37b9b000ce880a45a4f35950c5b8c104076d84ecd1269e90549c4e72df9662b1ea768dc7488ba0f07bd89c9653f8367704e030b94338e6e55100fd7c8a60653023349b96a182c4f4e5d4b90f84f85f47101e817c40fd7feb21b224c162715a549e6a34931bf2c4c325512ccd3c842bef738436a3afd23061474a9f72eecb96a1c912cce588ec0984170869885b0fdaeab85e51e94e60a16cc3243dddf1511b4d77150eb386ba1f5936ab21c033963a1308e207369cd021dc5f3fe85ad1cdd9f08de2be449037a21f5d2c707a5962e21203e8661c2389c1eee6268aa78f47aa84bd022b0a3a63c942c4f08ac7a235fd3bfc066cd4c469354adc755af9ac5c1a773eb075646db24556155837b2882d7ff3fb3095c4ae8e3ebe729b13394b1b62848a9452f389fb108428d12674e6d74912a9ae59126c92cc166b1cbb4d811a6abe2512025a1d84f2639154e8127415c2cfcb2dbf5e3bc19f4f64e8f4462dea494d861c5ac431e8c9091e6f95b6b58b26dee25b2fa6fa9a95ab0693ab42055032223cd0a7b2009e05a0b5dbc86163eb493d2dd565143fe6858bc51a396277d0bd36adec5aba6a7979360538e4477a6e059faf697176b478e2a8797ed379e55ab38546df4612772132e64a02d592c0944128c1beee05c90fbf7723d64588384307630ddce9f793777242738b9e2a96c5de6a9355611ff64ff8a6215728f313cb69724e42be7f0f16070566f76519e3d0f47da8b181c5689f8d47a97accf0d0359549ab346e1163fb33b4df23e66c2341c72aad8d69aa304aed3c1c459cfa1e089f80308c26ac75d1c68dfbafd7ac04656aca2757cfe6d425c22a046c9ef326b0908049d51632c1bc90a191939805d30d275ff23169bbdef57c44b3bb8c6a9bcbb7470f984331f987baa99e11570b8793051b446cd50ba61f53cdd175634197e24fdedc3c12c8ae12196fa3b417ac9c2b119770b0f266267218c45186e1516bca192c62d3fa277688d573fee04e974661fbe86107d3e1eef3ec279436f75561e519c2ec11af3a449d4aa955354522e458a1e793548ab6a2027f919960d0dc21055c26860b3e76e6e040730747fcecd6b638f9d9b34646b204b3970e72d14a2ff2bd3456a3063af224dee2d3d1e7b3c04707c2a7354428cde05fc342ee580a8b83aa65c205f581019d215640bc78caea1b76ce9e94b7ce51d649ed83e2b5c163d1e487fb919bece10eb510f428bee4b50661db706d58ecbda8e6189342d55fd59f6edb2bb0cde3528fcc8c8d8cc4207b00146c46591a5e049dae3912fb9cc889e6bb5781c6a78fd602d0b00f33e24e525d2ea650c3841a970f07a599c8e2d7c3e0f5624b025c8f898a32a705a117ab465794aa59ee4d04c1711c24a80505c0059b3e8b5ad6cdaa6cf4e42ded0bf606361cca77ab28a94a6c6d6c320caa06d8afa92acf931795d45154289d529122554f8abf75f5fbcda3cb4ccb7fb469d479de44239b3d6c7946ca27a4ef8726df8afe33a81f345294efc63fab2257412db4ae9f8aa7a79a381ced451fcb3680143c4993d9cb91625295a19d61e1f0a19f757ebb2acc4e77d534766c2053f74dbd8a136cbf3392d128866d57751818f0f52b468d333f46d82a40bdb7302db292ebee090150fe5e1b22fc69b5fd07c31d98e6e61784cb47548acdfabe862c05186db7f16d6249ea0cd52863e7731a230688dbd7e030f1426f9c0ae2305fe4653d4296c14d9e223617ede7d4ec5171b162a52755eed174fb403665f8ac8145146eaf15c58b40d70d354a8986689283189ae80e0a180fa40ce0df5bb721b2a2f41562b6cb3dbffa4d71e45b2720586517c34574356cf81eced26e4523b4592b4a68454f429499da6a8fb816541f94ba1769e9ded5adbfad7cc0482c73e54ac5eab7f24c0d4b7673782462df0e55704ca53af550d14c0b60ffbd6f548c31c9d127d3eb64527cf15780c0e4217ca3578c75797fc26e8261d33824472801414ecd41ffe4289b8ba32dc8d4f7884f0e7b0d8807d9a625e7f2e34b0ce2d9b5f10e11445591c19515c74f0a0ec875c22afaf6b43736684059ea088d8db84f742ab1b6b99f3db7010e5e0cf8ae1b26b4b89751b5342325d01382b2ff459e51c7ea4d763809f7148eb33c027560f515fd348be887ca075dc4cbe44186e89b59e280f85030d74969574dc139cd7241f84968822df5cc5203c26a576ca8888b2da05cb7730b15a0e9e14d5463ff06b62cd45f9e3b7a54c1893c44b146fe7d4662f7e119b5cab621515d5911207fe983d8f49cbf77db2db5fbe4a59c5bd06a9b77747d68aa01732836d977145fbd85935ea86ee529b728996c8a2830896ff9469aee12a5ae76f4b69e5d357bb3894233feafcd52b41e0699c4684c166335361dfc156569743041a81de6e3fc03f1fe6322c0eaffe432a53ffd245bc86012ce6ff84d65229e214e2acd601578a3580ca8e5635ef95fcdc55af8c15d23f4ef1421899989a87ffcdf2811b6b1ec545ece747d1bfeea40be95bd1f390944b0fdcd6e4a84b7003f940700ebcbbe37a7bc4f92165b0342d252db7136714971a136d95eccd8ab9646731418aa1abe3f9afa5d78786fd5cd9372ac61e13d355b12eae52d3d088781635767fc73db622e113a31502ece0ed255b136cf7d86037f823fbc82162c3f88a661a281354152dd7704b4bf2f318457d15dbdecd3680a507bddb586699ddb6cb5dbc69c09a44a631f22834424dda48325ab6d0c1fdc66364f878465767f64a3b1a4a3a941be78b6aae6a7c7a977d5181e9c9092f9a7bba87edc73fdc57a166f9826d966caea5a8f217be467976139458d3225d9ec3e354d1da89ad75ba2693d27d22ea2983d49000fc42f390d47298b5394785c0ede6db8c4167143152df0616eed7a9e6f045a467df594fa9bac63d7e289ad3ea95f3c57bdcf947a3c0568d93eb20ff2afc325d60b0a9ec1c94118655a9b6eceab73004cf9205c93e79a7bd9332e3482f0154d9d0890b9710e70b91d245232b657811d1792382e6ff47ee60078f632aee89239f05cb2e124d7f197d4ca03a00d6bd6207cbfea131d65b1a9ecdc638a057ddbe79889bb84f534a1092f05eb7f1f3f578c70a146ea1c850c7bf1a4429823ec1b807806014b46f56f9bfbcae036de767e758355d12d4182ef23567d670e7112078f9be255fe7e8b8709c9a81de43d619cef5ca701f5d2e321a707894894fc954deb5b0fef55a759ed9cb988fef41e7e0862668f51a57a4db1128c473ee86af31b5b58f42144eab2c5372d2da2c009b53101017edd8497437e4fd31a1787ec384af0f4694cf6c47054972cd593232e7f2599ba484dfb1d4a2d9a44351ed942c0ac20bd4b3b75965298f3bb96317d433fcaeacbdcce8b1b192727642f1eb3bf22dc3883f472b8bb9629aa196b4fb636f1d1311ab4651c831f5d58d10cf4746bdac4036b78224d093095f2cc55fdd04a9d1d31f68fe3f4972b56f916e311c3506d4b9c58352e4ccfa3a370a5e664101bda9edab8cac55308499fd0ff1262df04e267fa3c2791e449364fd248990077ad70ae97a0f5841ee30c235e1f4d5f742afbf15a41175ab76093a6ba7fcc52d5616a69e149985f1381d62fab2c688de1dbd623330b0b46626f4d6168cf8b156fdcb77ed8341d1f912e44c36c421b56387582c2a5c5af81aecc423863ef08a4a1b0d1f4cd7714fb409d2531f9f32bf59972c114a2e75d43bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"b230c769d3828eba41c952554449339e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
